import { WebSocket } from 'ws';
import { config } from '../config/index.js';
import { generateMusicViaAPI, getJobStatus, downloadAudioToBuffer, setMusicProviderUrl } from './music/index.js';
import { getStorageProvider } from './storage/factory.js';
import { generateUUID } from '../db/sqlite.js';
// Import migrate first to ensure tables exist before RadioManager queries them
import '../db/migrate.js';
import { db } from '../db/pool.js';
import { generateWithLLM, initLLMProvider, type LLMSongData } from './llm/index.js';
import { processAudioWithSettings } from './audioProcessor.js';

// Re-export LLMSongData for backwards compat
export type { LLMSongData } from './llm/index.js';

// Generation params for auto-generation
export interface AutoGenParams {
  customMode: boolean;
  songDescription?: string;
  lyrics?: string;
  style?: string;
  title?: string;
  instrumental?: boolean;
  vocalLanguage?: string;
  // Instruct mode params
  instructMode?: boolean;
  instructParams?: InstructParams;
  // LLM-generated data from previous generation (for instruct mode iterations)
  llmData?: LLMSongData;
}

export interface RadioSettings {
  // Universal generation settings (provider-agnostic)
  batchSize: number;
  audioFormat: 'mp3' | 'flac';
  randomSeed: boolean;
  seed: number;
  duration: number; // -1 for auto

  // Music provider abstraction
  musicProvider?: string;                          // 'acestep' (default)
  musicProviderUrl?: string;                       // API URL for the music provider
  musicProviderSettings?: Record<string, unknown>; // Provider-specific blob

  // Legacy flat fields (kept for backward compat, migrated to musicProviderSettings on load)
  inferenceSteps: number;
  guidanceScale: number;
  inferMethod: 'ode' | 'sde';
  shift: number;
  thinking: boolean;
  lmTemperature: number;
  lmCfgScale: number;
  lmTopK: number;
  lmTopP: number;
  lmNegativePrompt: string;
  useCotCaption?: boolean;
  constrainedDecoding?: boolean;

  // LLM integration
  useLLM?: boolean;
  llmProvider?: 'claude' | 'vllm';
  llmClaudeSettings?: {
    apiKey?: string;
    temperature: number;
    maxTokens: number;
    model: string;
  };
  llmVllmSettings?: {
    endpointUrl: string;
    model: string;
    temperature: number;
    maxTokens: number;
    supportsAudio: boolean;
  };
  // Audio post-processing
  audioPostProcess?: boolean;
  audioHighPass?: number;      // Hz, 0 to disable
  audioLowPass1?: number;      // Hz, 0 to disable (gentle roll-off)
  audioLowPass2?: number;      // Hz, 0 to disable (steep roll-off)
  // Auto-DJ controls
  autoDjFreshLLM?: boolean;
  autoDjStyle?: 'explore' | 'similar' | 'consistent';
  autoDjStyleLocked?: boolean;
  autoDjPrompt?: string;
  autoDjBpmVariation?: boolean;
  autoDjBpmMin?: number;
  autoDjBpmMax?: number;
  autoDjDurationMin?: number;
  autoDjDurationMax?: number;
  autoDjKeyRandomize?: boolean;
  autoDjForceInstrumental?: boolean;
  autoDjLanguage?: string;
  autoDjMinQueueSize?: number;
  autoDjPreGenSeconds?: number;
  autoDjFadeIn?: number;
  autoDjFadeOut?: number;
  // Interaction mode
  interactionMode?: 'vibe' | 'create';
}

export interface InstructParams {
  effects: string[];
  customInstruction?: string;
}

export interface RadioSong {
  id: string;
  title: string;
  lyrics: string;
  style: string;
  coverUrl: string;
  audioUrl: string;
  duration: number; // in seconds
  creator?: string;
  createdAt: Date;
  genParams?: AutoGenParams; // Generation params for details popup
  isAutoDJ?: boolean; // True if generated by Auto-DJ (can be replaced by user songs)
}

export interface Listener {
  id: string;
  name: string;
  joinedAt: Date;
  ws: WebSocket;
}

export interface ChatMessage {
  id: string;
  senderId?: string; // Optional - not stored in DB, only for live broadcasts
  senderName: string;
  message: string;
  timestamp: number;
}

export interface RadioState {
  currentSong: RadioSong | null;
  playbackStartTime: number; // timestamp when current song started
  queue: RadioSong[];
  history: RadioSong[]; // Previously played songs
  chatMessages: ChatMessage[]; // Chat history
  listeners: Map<string, Listener>;
  skipVotes: Set<string>;
  djStyleVotes: Map<string, 'explore' | 'similar' | 'consistent'>;
  ownerId: string | null;
  settings: RadioSettings;
  lastGenParams: AutoGenParams | null; // For auto-generation when queue is empty
  isAutoGenerating: boolean; // Prevent multiple concurrent auto-generations
  pendingSkip: boolean; // Skip requested but waiting for next song to be ready
  autoGenStale: boolean; // Mark ongoing auto-generation as stale (user request came in)
}

type RadioEvent =
  | { type: 'state'; payload: ReturnType<RadioManager['getPublicState']> }
  | { type: 'song-change'; payload: { song: RadioSong | null; startTime: number } }
  | { type: 'queue-update'; payload: { queue: RadioSong[] } }
  | { type: 'history-update'; payload: { history: RadioSong[] } }
  | { type: 'listeners-update'; payload: { listeners: Array<{ id: string; name: string }>; count: number } }
  | { type: 'skip-votes-update'; payload: { votes: number; required: number } }
  | { type: 'dj-style-votes-update'; payload: { votes: { explore: number; similar: number; consistent: number }; current: string; required: number; locked: boolean } }
  | { type: 'owner-change'; payload: { ownerId: string | null } }
  | { type: 'settings-update'; payload: { settings: RadioSettings } };

// Available key/scales for Auto-DJ randomization
const KEY_SCALES = [
  'C major', 'C minor', 'C# major', 'C# minor',
  'D major', 'D minor', 'Eb major', 'Eb minor',
  'E major', 'E minor', 'F major', 'F minor',
  'F# major', 'F# minor', 'G major', 'G minor',
  'Ab major', 'Ab minor', 'A major', 'A minor',
  'Bb major', 'Bb minor', 'B major', 'B minor',
];

class RadioManager {
  private state: RadioState;
  private songEndTimeout: ReturnType<typeof setTimeout> | null = null;
  private preGenerateTimeout: ReturnType<typeof setTimeout> | null = null;
  /** Pre-gen lead time — reads from settings, falls back to 15s */
  private get preGenerateSeconds(): number {
    return this.state.settings.autoDjPreGenSeconds ?? 15;
  }

  constructor() {
    this.state = {
      currentSong: null,
      playbackStartTime: 0,
      queue: [],
      history: [],
      chatMessages: [],
      listeners: new Map(),
      skipVotes: new Set(),
      djStyleVotes: new Map(),
      ownerId: null,
      settings: { ...config.radio.defaultSettings },
      lastGenParams: null,
      isAutoGenerating: false,
      pendingSkip: false,
      autoGenStale: false,
    };

    // Load history, settings, and chat from database on startup
    this.loadHistoryFromDb();
    this.loadSettingsFromDb();
    this.loadChatFromDb();
  }

  private loadSettingsFromDb(): void {
    try {
      const stmt = db.prepare('SELECT settings FROM radio_settings WHERE id = 1');
      const row = stmt.get() as { settings: string } | undefined;
      if (row?.settings) {
        const savedSettings = JSON.parse(row.settings) as Record<string, unknown>;

        // Migrate old Claude-specific settings to new LLM schema
        if ('useClaude' in savedSettings && !('useLLM' in savedSettings)) {
          console.log('[Radio] Migrating old Claude settings to new LLM schema');
          savedSettings.useLLM = savedSettings.useClaude;
          savedSettings.llmProvider = 'claude';
          savedSettings.llmClaudeSettings = {
            temperature: (savedSettings.claudeTemperature as number) ?? 1.0,
            maxTokens: (savedSettings.claudeMaxTokens as number) ?? 4096,
            model: (savedSettings.claudeModel as string) ?? 'claude-sonnet-4-20250514',
          };
          delete savedSettings.useClaude;
          delete savedSettings.claudeTemperature;
          delete savedSettings.claudeMaxTokens;
          delete savedSettings.claudeModel;
        }

        // Migrate flat ACE-Step fields into musicProviderSettings
        if (!savedSettings.musicProviderSettings) {
          const aceStepKeys = [
            'inferenceSteps', 'guidanceScale', 'shift', 'inferMethod', 'thinking',
            'lmTemperature', 'lmCfgScale', 'lmTopK', 'lmTopP', 'lmNegativePrompt',
            'useCotCaption', 'constrainedDecoding',
          ];
          const mps: Record<string, unknown> = {};
          let hasMps = false;
          for (const key of aceStepKeys) {
            if (key in savedSettings) {
              mps[key] = savedSettings[key];
              hasMps = true;
            }
          }
          if (hasMps) {
            savedSettings.musicProviderSettings = mps;
            savedSettings.musicProvider = savedSettings.musicProvider || 'acestep';
            console.log('[Radio] Migrated flat ACE-Step settings to musicProviderSettings');
          }
        }

        this.state.settings = { ...config.radio.defaultSettings, ...savedSettings } as RadioSettings;
        console.log('[Radio] Loaded settings from database');

        // Initialize LLM provider from saved settings
        this.initLLMFromSettings();
      }
    } catch (error) {
      console.error('[Radio] Failed to load settings from database:', error);
    }
  }

  /** Get provider-specific temperature/maxTokens/model from current settings */
  getLLMProviderSettings(): { temperature?: number; maxTokens?: number; model?: string } {
    const s = this.state.settings;
    if (s.llmProvider === 'vllm' && s.llmVllmSettings) {
      return {
        temperature: s.llmVllmSettings.temperature,
        maxTokens: s.llmVllmSettings.maxTokens,
        model: s.llmVllmSettings.model,
      };
    }
    // Default: Claude settings
    if (s.llmClaudeSettings) {
      return {
        temperature: s.llmClaudeSettings.temperature,
        maxTokens: s.llmClaudeSettings.maxTokens,
        model: s.llmClaudeSettings.model,
      };
    }
    return {};
  }

  /** Get music provider-specific settings (from nested musicProviderSettings or flat fields) */
  getMusicProviderSettings(): Record<string, unknown> {
    const s = this.state.settings;
    if (s.musicProviderSettings) return s.musicProviderSettings;
    // Fallback: read from legacy flat fields
    return {
      inferenceSteps: s.inferenceSteps,
      guidanceScale: s.guidanceScale,
      shift: s.shift,
      inferMethod: s.inferMethod,
      thinking: s.thinking,
      lmTemperature: s.lmTemperature,
      lmCfgScale: s.lmCfgScale,
      lmTopK: s.lmTopK,
      lmTopP: s.lmTopP,
      lmNegativePrompt: s.lmNegativePrompt,
      useCotCaption: s.useCotCaption,
      constrainedDecoding: s.constrainedDecoding,
    };
  }

  /** Re-initialize the LLM provider based on current settings */
  initLLMFromSettings(): void {
    const s = this.state.settings;
    if (s.useLLM && s.llmProvider) {
      if (s.llmProvider === 'vllm' && s.llmVllmSettings) {
        initLLMProvider('vllm', s.llmVllmSettings);
      } else {
        initLLMProvider('claude', { apiKey: s.llmClaudeSettings?.apiKey });
      }
    }
  }

  private saveSettingsToDb(): void {
    try {
      const stmt = db.prepare(`
        INSERT INTO radio_settings (id, settings, updated_at)
        VALUES (1, ?, datetime('now'))
        ON CONFLICT(id) DO UPDATE SET settings = excluded.settings, updated_at = datetime('now')
      `);
      stmt.run(JSON.stringify(this.state.settings));
      console.log('[Radio] Saved settings to database');
    } catch (error) {
      console.error('[Radio] Failed to save settings to database:', error);
    }
  }

  private loadChatFromDb(): void {
    try {
      const stmt = db.prepare(`
        SELECT id, sender_name, message, created_at
        FROM radio_chat
        ORDER BY created_at DESC
        LIMIT 100
      `);
      const rows = stmt.all() as Array<{
        id: string;
        sender_name: string;
        message: string;
        created_at: string;
      }>;

      // Reverse to get oldest first
      this.state.chatMessages = rows.reverse().map(row => ({
        id: row.id,
        senderName: row.sender_name,
        message: row.message,
        timestamp: new Date(row.created_at).getTime(),
      }));

      console.log(`[Radio] Loaded ${this.state.chatMessages.length} chat messages from history`);
    } catch (error) {
      console.error('[Radio] Failed to load chat from database:', error);
    }
  }

  private saveChatMessage(chatMessage: ChatMessage): void {
    try {
      const stmt = db.prepare(`
        INSERT INTO radio_chat (id, sender_name, message, created_at)
        VALUES (?, ?, ?, datetime('now'))
      `);
      stmt.run(chatMessage.id, chatMessage.senderName, chatMessage.message);

      // Cleanup old messages (keep last 500)
      const cleanupStmt = db.prepare(`
        DELETE FROM radio_chat WHERE id NOT IN (
          SELECT id FROM radio_chat ORDER BY created_at DESC LIMIT 500
        )
      `);
      cleanupStmt.run();
    } catch (error) {
      console.error('[Radio] Failed to save chat message:', error);
    }
  }

  private loadHistoryFromDb(): void {
    try {
      const stmt = db.prepare(`
        SELECT id, title, lyrics, style, cover_url, audio_url, duration, creator, created_at, gen_params
        FROM radio_history
        ORDER BY played_at DESC
        LIMIT 50
      `);
      const rows = stmt.all() as Array<{
        id: string;
        title: string;
        lyrics: string | null;
        style: string | null;
        cover_url: string | null;
        audio_url: string;
        duration: number | null;
        creator: string | null;
        created_at: string | null;
        gen_params: string | null;
      }>;

      this.state.history = rows.map(row => ({
        id: row.id,
        title: row.title,
        lyrics: row.lyrics || '',
        style: row.style || '',
        coverUrl: row.cover_url || `https://picsum.photos/seed/${row.id}/400/400`,
        audioUrl: row.audio_url,
        duration: row.duration || 0,
        creator: row.creator || undefined,
        createdAt: row.created_at ? new Date(row.created_at) : new Date(),
        genParams: row.gen_params ? JSON.parse(row.gen_params) : undefined,
      }));

      console.log(`[Radio] Loaded ${this.state.history.length} songs from history`);
    } catch (error) {
      console.error('[Radio] Failed to load history from database:', error);
    }
  }

  private saveToHistory(song: RadioSong): void {
    try {
      const stmt = db.prepare(`
        INSERT OR REPLACE INTO radio_history (id, title, lyrics, style, cover_url, audio_url, duration, creator, created_at, played_at, gen_params)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), ?)
      `);
      stmt.run(
        song.id,
        song.title,
        song.lyrics,
        song.style,
        song.coverUrl,
        song.audioUrl,
        song.duration,
        song.creator || null,
        song.createdAt.toISOString(),
        song.genParams ? JSON.stringify(song.genParams) : null
      );
      console.log('[Radio] Saved song to history:', song.title);
    } catch (error) {
      console.error('[Radio] Failed to save song to history:', error);
    }
  }

  addListener(ws: WebSocket, name: string): string {
    const id = `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const listener: Listener = {
      id,
      name,
      joinedAt: new Date(),
      ws,
    };
    this.state.listeners.set(id, listener);

    // Send initial state to the new listener
    this.sendTo(ws, { type: 'state', payload: this.getPublicState() });

    // Send chat history to new listener
    this.sendChatHistory(ws);

    // Broadcast listener update to all
    this.broadcastListenersUpdate();

    return id;
  }

  private sendChatHistory(ws: WebSocket): void {
    // Send all chat messages to the new listener
    this.state.chatMessages.forEach(msg => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'chat-message',
          payload: msg,
        }));
      }
    });
  }

  removeListener(id: string): void {
    const listener = this.state.listeners.get(id);
    if (!listener) return;

    this.state.listeners.delete(id);
    this.state.skipVotes.delete(id);
    this.state.djStyleVotes.delete(id);

    // If owner disconnects, clear owner
    if (this.state.ownerId === id) {
      this.state.ownerId = null;
      this.broadcastOwnerChange();
    }

    this.broadcastListenersUpdate();
    this.broadcastSkipVotesUpdate();
    this.broadcastDjStyleVotesUpdate();
  }

  addToQueue(song: RadioSong, genParams?: AutoGenParams, isUserGenerated: boolean = false): void {
    console.log('[Radio] Adding song to queue:', song.title, isUserGenerated ? '(user)' : '(auto-dj)');

    // Reject duplicate audioUrls (safety net for race conditions)
    const isDuplicate = this.state.queue.some(s => s.audioUrl === song.audioUrl)
      || this.state.currentSong?.audioUrl === song.audioUrl;
    if (isDuplicate) {
      console.log('[Radio] Rejecting duplicate song (same audioUrl):', song.title);
      return;
    }

    // Attach genParams to the song for the details popup
    if (genParams) {
      song.genParams = genParams;
      // Only update lastGenParams for user-generated songs
      if (isUserGenerated) {
        this.state.lastGenParams = genParams;
        console.log('[Radio] Stored generation params for auto-generation');
      }
    }

    // Mark Auto-DJ songs
    if (!isUserGenerated) {
      song.isAutoDJ = true;
    }

    // If user is adding a song, remove Auto-DJ songs after the first queue position
    // This gives user songs priority while keeping one song ready
    if (isUserGenerated && this.state.queue.length > 0) {
      const firstSong = this.state.queue[0];
      // Keep only the first song if it's not Auto-DJ, otherwise clear the queue
      if (firstSong.isAutoDJ) {
        // Remove the first Auto-DJ song to make room for user's song
        console.log('[Radio] Removing Auto-DJ song to prioritize user song');
        this.state.queue = [];
      } else {
        // Keep the first user song, remove any Auto-DJ songs after it
        this.state.queue = this.state.queue.filter((s, i) => i === 0 || !s.isAutoDJ);
      }
    }

    this.state.queue.push(song);
    this.broadcastQueueUpdate();

    // If nothing is playing, start playback
    if (!this.state.currentSong) {
      console.log('[Radio] No current song, starting playback...');
      this.playNext();
    }
    // If skip was pending (waiting for next song), now skip to it
    else if (this.state.pendingSkip) {
      console.log('[Radio] Pending skip resolved - new song ready, skipping now');
      this.state.pendingSkip = false;

      // Clear pending notification
      this.broadcastToAll({
        type: 'skip-pending',
        payload: { pending: false },
      } as any);

      this.playNext();
    } else {
      console.log('[Radio] Current song playing:', this.state.currentSong.title, '- queue size:', this.state.queue.length);
    }
  }

  voteSkip(listenerId: string): boolean {
    if (!this.state.currentSong) return false;
    if (!this.state.listeners.has(listenerId)) return false;

    this.state.skipVotes.add(listenerId);
    this.broadcastSkipVotesUpdate();

    // Check if enough votes to skip
    const required = this.getSkipRequired();
    if (this.state.skipVotes.size >= required) {
      return this.requestSkip();
    }

    return false;
  }

  /**
   * Request a skip - if next song is ready, skip immediately.
   * If queue is empty, keep current song playing while generating next.
   */
  private requestSkip(): boolean {
    if (!this.state.currentSong) return false;

    // If there's a song in the queue, skip immediately
    if (this.state.queue.length > 0) {
      console.log('[Radio] Skip requested - next song ready, skipping immediately');
      this.playNext();
      return true;
    }

    // Queue is empty - keep current song playing while generating
    if (this.state.lastGenParams && !this.state.isAutoGenerating) {
      console.log('[Radio] Skip requested - queue empty, generating next song while current plays');
      this.state.pendingSkip = true;

      // Broadcast that skip is pending
      this.broadcastToAll({
        type: 'skip-pending',
        payload: { pending: true, message: 'Generating next song...' },
      } as any);

      this.autoGenerate();
      return true;
    }

    // If already generating, just mark pending skip
    if (this.state.isAutoGenerating) {
      console.log('[Radio] Skip requested - already generating, will skip when ready');
      this.state.pendingSkip = true;

      this.broadcastToAll({
        type: 'skip-pending',
        payload: { pending: true, message: 'Waiting for next song...' },
      } as any);

      return true;
    }

    // No way to generate next song, just skip (will result in silence)
    console.log('[Radio] Skip requested - no generation params, stopping playback');
    this.playNext();
    return true;
  }

  ownerSkip(listenerId: string): boolean {
    if (this.state.ownerId !== listenerId) return false;
    return this.requestSkip();
  }

  claimOwner(listenerId: string, secret: string): boolean {
    console.log('[Radio] Claim owner attempt:', {
      listenerId,
      providedSecret: secret,
      expectedSecret: config.radio.ownerSecret,
      secretMatch: secret === config.radio.ownerSecret,
      listenerExists: this.state.listeners.has(listenerId),
    });

    if (secret !== config.radio.ownerSecret) {
      console.log('[Radio] Secret mismatch!');
      return false;
    }
    if (!this.state.listeners.has(listenerId)) {
      console.log('[Radio] Listener not found!');
      return false;
    }

    this.state.ownerId = listenerId;
    this.broadcastOwnerChange();
    console.log('[Radio] Owner claimed successfully:', listenerId);
    return true;
  }

  isOwner(listenerId: string): boolean {
    return this.state.ownerId === listenerId;
  }

  playNext(): void {
    console.log('[Radio] playNext called, queue size:', this.state.queue.length);

    // Clear pending skip flag
    this.state.pendingSkip = false;

    // Clear any existing timeouts
    if (this.songEndTimeout) {
      clearTimeout(this.songEndTimeout);
      this.songEndTimeout = null;
    }
    if (this.preGenerateTimeout) {
      clearTimeout(this.preGenerateTimeout);
      this.preGenerateTimeout = null;
    }

    // Add current song to history before switching
    if (this.state.currentSong) {
      console.log('[Radio] Adding to history:', this.state.currentSong.title);

      // Save to database for persistence
      this.saveToHistory(this.state.currentSong);

      this.state.history.unshift(this.state.currentSong); // Add to front
      // Keep only last 50 songs in history
      if (this.state.history.length > 50) {
        this.state.history = this.state.history.slice(0, 50);
      }
      this.broadcastHistoryUpdate();
    }

    // Clear skip votes
    this.state.skipVotes.clear();

    // Get next song from queue
    const nextSong = this.state.queue.shift();
    console.log('[Radio] Next song:', nextSong?.title || 'none');

    if (nextSong) {
      this.state.currentSong = nextSong;
      this.state.playbackStartTime = Date.now();
      console.log('[Radio] Now playing:', nextSong.title, 'duration:', nextSong.duration);

      // Schedule next song when current ends
      if (nextSong.duration > 0) {
        console.log('[Radio] Scheduling next song in', nextSong.duration, 'seconds');
        this.songEndTimeout = setTimeout(() => {
          this.playNext();
        }, nextSong.duration * 1000 + 500); // Add small buffer

        // Schedule pre-generation if queue will be empty
        const preGenTime = (nextSong.duration - this.preGenerateSeconds) * 1000;
        if (preGenTime > 0) {
          this.preGenerateTimeout = setTimeout(() => {
            this.checkAndPreGenerate();
          }, preGenTime);
          console.log('[Radio] Pre-generation scheduled in', nextSong.duration - this.preGenerateSeconds, 'seconds');
        }
      } else {
        console.log('[Radio] WARNING: Song has no duration, will not auto-advance');
      }
    } else {
      console.log('[Radio] Queue empty, no song to play');
      this.state.currentSong = null;
      this.state.playbackStartTime = 0;

      // Trigger auto-generation if we have previous params
      if (this.state.lastGenParams && !this.state.isAutoGenerating) {
        console.log('[Radio] Triggering auto-generation with last params...');
        this.autoGenerate();
      }
    }

    // Check if we need more Auto-DJ songs in queue
    const minQueue = this.state.settings.autoDjMinQueueSize ?? 1;
    const autoDJCount = this.state.queue.filter(s => s.isAutoDJ).length;
    if (autoDJCount < minQueue && this.state.lastGenParams && !this.state.isAutoGenerating) {
      console.log(`[Radio] Auto-DJ queue (${autoDJCount}/${minQueue}), starting pre-generation`);
      this.autoGenerate();
    }

    console.log('[Radio] Broadcasting song change...');
    this.broadcastSongChange();
    this.broadcastQueueUpdate();
    this.broadcastSkipVotesUpdate();
  }

  private checkAndPreGenerate(): void {
    const minQueue = this.state.settings.autoDjMinQueueSize ?? 1;
    const autoDJCount = this.state.queue.filter(s => s.isAutoDJ).length;

    if (autoDJCount < minQueue && this.state.lastGenParams && !this.state.isAutoGenerating) {
      console.log(`[Radio] Auto-DJ queue (${autoDJCount}/${minQueue}), pre-generating next song...`);
      this.autoGenerate();
    } else {
      console.log(`[Radio] Pre-generation check: ${autoDJCount}/${minQueue} Auto-DJ songs in queue, ${this.state.isAutoGenerating ? 'already generating' : 'skipping'}`);
    }
  }

  private async autoGenerate(): Promise<void> {
    if (!this.state.lastGenParams || this.state.isAutoGenerating) {
      return;
    }

    this.state.isAutoGenerating = true;
    console.log('[Radio] Starting auto-generation...');

    // Broadcast that we're generating
    this.broadcastToAll({
      type: 'auto-generating',
      payload: { isGenerating: true },
    } as any);

    try {
      const lastParams = this.state.lastGenParams!;

      // Always generate 1 song at a time for auto-DJ
      const songsNeeded = 1;

      // Start with base params
      let lyrics = lastParams.lyrics || '';
      let style = lastParams.style || '';
      let title = lastParams.title || '';
      let duration = this.state.settings.duration;
      let bpm: number | undefined;
      let keyScale: string | undefined;
      let timeSignature: string | undefined;

      // Apply LLM generation if enabled (works with any mode: simple, custom, or instruct)
      const freshLLM = this.state.settings.autoDjFreshLLM ?? false;

      if (this.state.settings.useLLM) {
        if (freshLLM) {
          // Fresh LLM mode: call LLM for every Auto-DJ song
          console.log('[Radio] Auto-DJ fresh LLM mode - generating unique song');
          try {
            const parts: string[] = [];

            // Use the Auto-DJ theme prompt if set, otherwise fall back to last user params
            const themePrompt = this.state.settings.autoDjPrompt?.trim();
            if (themePrompt) {
              parts.push(themePrompt);
            } else if (lastParams.songDescription) {
              parts.push(lastParams.songDescription);
            } else if (lastParams.style) {
              parts.push(lastParams.style);
            }

            if (lastParams.title && !themePrompt) {
              parts.push(`Song title: ${lastParams.title}`);
            }

            // Add constraints from Auto-DJ settings
            const forceInstrumental = this.state.settings.autoDjForceInstrumental ?? false;
            if (forceInstrumental || lastParams.instrumental) {
              parts.push('This should be instrumental music (no vocals).');
            }

            const djLanguage = this.state.settings.autoDjLanguage?.trim();
            if (djLanguage) {
              parts.push(`Vocal language: ${djLanguage}`);
            } else if (lastParams.vocalLanguage && lastParams.vocalLanguage !== 'en' && lastParams.vocalLanguage !== 'unknown') {
              parts.push(`Vocal language: ${lastParams.vocalLanguage}`);
            }

            const djStyle = this.state.settings.autoDjStyle || 'explore';
            switch (djStyle) {
              case 'similar':
                parts.push('Generate a new song that keeps a similar genre, mood, and energy to the previous one, but with fresh lyrics, melody, arrangement and name.');
                break;
              case 'consistent':
                parts.push('Generate a song that closely matches the style, mood, genre, and energy of the previous one. Keep the same vibe — only vary the specific lyrics/make it instrumental and melody.');
                break;
              case 'explore':
              default:
                parts.push('Generate a completely new and unique song that\'s distinctly different from previous ones. Explore a different genre, mood, or style but make the progression make sense.');
                break;
            }

            const userPrompt = parts.join('\n\n');
            console.log('[Radio] Fresh LLM prompt:', userPrompt.slice(0, 200));

            const providerSettings = this.getLLMProviderSettings();
            const generated = await generateWithLLM({
              userPrompt,
              isInstructMode: false,
              previousData: undefined,
              ...providerSettings,
            });

            if (generated.song_title) { title = generated.song_title; console.log('[Radio] Fresh LLM title:', title); }
            if (generated.prompt) { style = generated.prompt; console.log('[Radio] Fresh LLM style:', style.slice(0, 100)); }
            if (generated.lyrics !== undefined) { lyrics = generated.lyrics; console.log('[Radio] Fresh LLM lyrics:', lyrics ? `${lyrics.length} chars` : 'empty'); }
            if (generated.audio_duration) { duration = generated.audio_duration; console.log('[Radio] Fresh LLM duration:', duration); }
            if (generated.bpm) { bpm = generated.bpm; console.log('[Radio] Fresh LLM BPM:', bpm); }
            if (generated.time_signature) { timeSignature = generated.time_signature; console.log('[Radio] Fresh LLM time signature:', timeSignature); }

            // Randomize key if enabled (default true)
            if (this.state.settings.autoDjKeyRandomize !== false) {
              keyScale = KEY_SCALES[Math.floor(Math.random() * KEY_SCALES.length)];
              console.log('[Radio] Auto-DJ randomized key:', keyScale);
            } else if (generated.key_scale) {
              keyScale = generated.key_scale;
              console.log('[Radio] Using LLM key:', keyScale);
            }
          } catch (llmError) {
            console.error('[Radio] Fresh LLM generation failed, falling back to cached params:', llmError);
            // Graceful degradation: fall back to cached data if available
            if (lastParams.llmData) {
              this.applyLLMData(lastParams.llmData, { title: t => title = t, style: s => style = s, lyrics: l => lyrics = l, duration: d => duration = d, bpm: b => bpm = b, keyScale: k => keyScale = k, timeSignature: t => timeSignature = t });
            }
          }
        } else if (lastParams.llmData) {
          // Cached mode: reuse stored LLM data (original behavior)
          console.log('[Radio] Auto-DJ reusing cached LLM data');
          const llmData = lastParams.llmData;

          if (llmData.song_title) { title = llmData.song_title; console.log('[Radio] Using cached title:', title); }
          if (llmData.prompt) { style = llmData.prompt; console.log('[Radio] Using cached style:', style.slice(0, 100)); }
          if (llmData.lyrics !== undefined) { lyrics = llmData.lyrics; console.log('[Radio] Using cached lyrics:', lyrics ? `${lyrics.length} chars` : 'empty (instrumental)'); }
          if (llmData.audio_duration) { duration = llmData.audio_duration; console.log('[Radio] Using cached duration:', duration); }
          if (llmData.bpm) { bpm = llmData.bpm; console.log('[Radio] Using cached BPM:', bpm); }
          // Randomize key if enabled (default true)
          if (this.state.settings.autoDjKeyRandomize !== false) {
            keyScale = KEY_SCALES[Math.floor(Math.random() * KEY_SCALES.length)];
            console.log('[Radio] Auto-DJ randomized key:', keyScale);
          } else if (llmData.key_scale) {
            keyScale = llmData.key_scale;
          }
          if (llmData.time_signature) { timeSignature = llmData.time_signature; console.log('[Radio] Using cached time signature:', timeSignature); }
        } else {
          // No cached LLM data - first auto-DJ generation, call LLM once then cache
          console.log('[Radio] Auto-DJ first generation - calling LLM once to get enhanced params');
          try {
            const parts: string[] = [];
            if (lastParams.songDescription) { parts.push(lastParams.songDescription); }
            else if (lastParams.style) { parts.push(lastParams.style); }
            if (lastParams.title) { parts.push(`Song title: ${lastParams.title}`); }
            if (lastParams.lyrics) { parts.push(`Lyrics:\n${lastParams.lyrics}`); }
            if (lastParams.instrumental) { parts.push('This should be instrumental music (no vocals).'); }
            if (lastParams.vocalLanguage && lastParams.vocalLanguage !== 'en' && lastParams.vocalLanguage !== 'unknown') {
              parts.push(`Vocal language: ${lastParams.vocalLanguage}`);
            }

            const userPrompt = parts.join('\n\n');
            console.log('[Radio] LLM user prompt:', userPrompt.slice(0, 200));

            const providerSettings = this.getLLMProviderSettings();
            const generated = await generateWithLLM({
              userPrompt,
              isInstructMode: false,
              previousData: undefined,
              ...providerSettings,
            });

            if (generated.song_title) { title = generated.song_title; console.log('[Radio] LLM set title:', title); }
            if (generated.prompt) { style = generated.prompt; console.log('[Radio] LLM set prompt/style:', style.slice(0, 100)); }
            if (generated.lyrics !== undefined) { lyrics = generated.lyrics; console.log('[Radio] LLM set lyrics:', lyrics ? `${lyrics.length} chars` : 'empty (instrumental)'); }
            if (generated.audio_duration) { duration = generated.audio_duration; console.log('[Radio] LLM set duration:', duration); }
            if (generated.bpm) { bpm = generated.bpm; console.log('[Radio] LLM set BPM:', bpm); }
            if (this.state.settings.autoDjKeyRandomize !== false) {
              keyScale = KEY_SCALES[Math.floor(Math.random() * KEY_SCALES.length)];
              console.log('[Radio] Auto-DJ randomized key:', keyScale);
            } else if (generated.key_scale) {
              keyScale = generated.key_scale;
            }
            if (generated.time_signature) { timeSignature = generated.time_signature; console.log('[Radio] LLM set time signature:', timeSignature); }

            this.state.lastGenParams!.llmData = generated;
            console.log('[Radio] Cached LLM data for future auto-DJ');
          } catch (llmError) {
            console.error('[Radio] LLM generation failed, using original params:', llmError);
          }
        }
      }

      // --- Auto-DJ variety overrides ---

      // BPM variation
      if (this.state.settings.autoDjBpmVariation) {
        const bpmMin = this.state.settings.autoDjBpmMin ?? 80;
        const bpmMax = this.state.settings.autoDjBpmMax ?? 160;
        bpm = Math.floor(Math.random() * (bpmMax - bpmMin + 1)) + bpmMin;
        console.log('[Radio] Auto-DJ BPM variation:', bpm, `(${bpmMin}-${bpmMax})`);
      }

      // Duration range
      const durMin = this.state.settings.autoDjDurationMin ?? 0;
      const durMax = this.state.settings.autoDjDurationMax ?? 0;
      if (durMin > 0 && durMax > 0 && durMax >= durMin) {
        duration = Math.floor(Math.random() * (durMax - durMin + 1)) + durMin;
        console.log('[Radio] Auto-DJ duration range:', duration, `(${durMin}-${durMax})`);
      }

      // Key randomization (only apply if not already handled in LLM path and enabled)
      if (!keyScale && (this.state.settings.autoDjKeyRandomize !== false)) {
        keyScale = KEY_SCALES[Math.floor(Math.random() * KEY_SCALES.length)];
        console.log('[Radio] Auto-DJ randomized key (non-LLM):', keyScale);
      }

      // Force instrumental
      let instrumental = lastParams.instrumental || false;
      if (this.state.settings.autoDjForceInstrumental) {
        instrumental = true;
        lyrics = '';
        console.log('[Radio] Auto-DJ forcing instrumental');
      }

      // Language override
      let vocalLanguage = lastParams.vocalLanguage;
      const djLang = this.state.settings.autoDjLanguage?.trim();
      if (djLang) {
        vocalLanguage = djLang;
        console.log('[Radio] Auto-DJ language override:', vocalLanguage);
      }

      // Use customMode when LLM has generated a style, so ACE-Step uses the
      // `style` field instead of the stale `songDescription` from the original request
      const useCustomMode = style ? true : lastParams.customMode;

      const params = {
        customMode: useCustomMode,
        songDescription: lastParams.songDescription,
        lyrics,
        style,
        title,
        instrumental,
        vocalLanguage,
        // Use Claude-enhanced or default values
        duration,
        bpm,
        keyScale,
        timeSignature,
        // Use radio settings for generation params
        inferenceSteps: this.state.settings.inferenceSteps,
        guidanceScale: this.state.settings.guidanceScale,
        batchSize: songsNeeded, // Generate 1 song at a time
        audioFormat: this.state.settings.audioFormat,
        inferMethod: this.state.settings.inferMethod,
        shift: this.state.settings.shift,
        // Disable thinking when LLM is enabled
        thinking: this.state.settings.useLLM ? false : this.state.settings.thinking,
        lmTemperature: this.state.settings.lmTemperature,
        lmCfgScale: this.state.settings.lmCfgScale,
        lmTopK: this.state.settings.lmTopK,
        lmTopP: this.state.settings.lmTopP,
        lmNegativePrompt: this.state.settings.lmNegativePrompt,
        randomSeed: this.state.settings.randomSeed,
        seed: this.state.settings.seed,
        // ACE-Step internal LM options
        useCotCaption: this.state.settings.useCotCaption,
        constrainedDecoding: this.state.settings.constrainedDecoding,
      };

      console.log(`[Radio] Calling ACE-Step API with batch size ${songsNeeded}...`);
      const { jobId } = await generateMusicViaAPI(params);
      console.log('[Radio] Job started:', jobId);

      // Poll for completion
      let resolved = false;
      const pollInterval = setInterval(async () => {
        if (resolved) return;
        try {
          const status = await getJobStatus(jobId);
          console.log('[Radio] Job status:', status.status);

          if (status.status === 'succeeded' && status.result) {
            if (resolved) return; // Double-check after await
            resolved = true;
            clearInterval(pollInterval);

            // Check if a user request made this generation stale
            if (this.state.autoGenStale) {
              console.log('[Radio] Auto-generation completed but marked stale — discarding');
              this.state.isAutoGenerating = false;
              this.state.autoGenStale = false;
              this.broadcastToAll({
                type: 'auto-generating',
                payload: { isGenerating: false },
              } as any);
              return;
            }

            const audioUrls = status.result.audioUrls?.filter((url: string) =>
              url.endsWith('.mp3') || url.endsWith('.flac')
            ) || [];

            if (audioUrls.length > 0) {
              console.log(`[Radio] Got ${audioUrls.length} audio files from batch`);

              // Process all audio files from the batch
              const storage = getStorageProvider();
              let songsAdded = 0;

              for (let i = 0; i < audioUrls.length; i++) {
                const audioUrl = audioUrls[i];
                console.log(`[Radio] Processing audio ${i + 1}/${audioUrls.length}:`, audioUrl);

                try {
                  // Download and store locally
                  let { buffer } = await downloadAudioToBuffer(audioUrl);
                  const songId = generateUUID();
                  const ext = audioUrl.includes('.flac') ? '.flac' : '.mp3';

                  // Apply audio post-processing if enabled
                  buffer = await processAudioWithSettings(buffer, {
                    audioPostProcess: this.state.settings.audioPostProcess,
                    audioHighPass: this.state.settings.audioHighPass,
                    audioLowPass1: this.state.settings.audioLowPass1,
                    audioLowPass2: this.state.settings.audioLowPass2,
                    audioFormat: ext.slice(1) as 'mp3' | 'flac',
                  });

                  const storageKey = `radio/${songId}${ext}`;
                  const publicUrl = await storage.upload(storageKey, buffer, `audio/${ext.slice(1)}`);

                  const song: RadioSong = {
                    id: songId,
                    title: `${params.title || params.songDescription?.slice(0, 50) || 'Auto-Generated'}${audioUrls.length > 1 ? ` (${i + 1})` : ''}`,
                    lyrics: params.lyrics || '',
                    style: params.style || params.songDescription || '',
                    coverUrl: `https://picsum.photos/seed/${songId}/400/400`,
                    audioUrl: publicUrl,
                    duration: status.result.duration || 120,
                    creator: 'Radio Auto-DJ',
                    createdAt: new Date(),
                  };

                  console.log('[Radio] Auto-generated song ready:', song.title);

                  // Add to queue (don't trigger checkAndPreGenerate for each, do it once at the end)
                  this.addToQueue(song, undefined, false);
                  songsAdded++;
                } catch (downloadError) {
                  console.error(`[Radio] Failed to download audio ${i + 1}:`, downloadError);
                  // Try with remote URL as fallback
                  const song: RadioSong = {
                    id: generateUUID(),
                    title: `${params.title || params.songDescription?.slice(0, 50) || 'Auto-Generated'}${audioUrls.length > 1 ? ` (${i + 1})` : ''}`,
                    lyrics: params.lyrics || '',
                    style: params.style || params.songDescription || '',
                    coverUrl: `https://picsum.photos/seed/${Date.now() + i}/400/400`,
                    audioUrl: audioUrl,
                    duration: status.result.duration || 120,
                    creator: 'Radio Auto-DJ',
                    createdAt: new Date(),
                  };
                  this.addToQueue(song, undefined, false);
                  songsAdded++;
                }
              }

              console.log(`[Radio] Added ${songsAdded} songs to queue`);
              this.state.isAutoGenerating = false;
              this.state.autoGenStale = false;

              // Only check for more generation if we still need songs
              const minQ = this.state.settings.autoDjMinQueueSize ?? 1;
              if (this.state.queue.filter(s => s.isAutoDJ).length < minQ) {
                this.checkAndPreGenerate();
              }
            } else {
              console.error('[Radio] No audio URLs in result');
              this.state.isAutoGenerating = false;
              this.state.autoGenStale = false;
            }

            this.broadcastToAll({
              type: 'auto-generating',
              payload: { isGenerating: false },
            } as any);

          } else if (status.status === 'failed') {
            if (resolved) return;
            resolved = true;
            clearInterval(pollInterval);
            console.error('[Radio] Auto-generation failed:', status.error);
            this.state.isAutoGenerating = false;
            this.state.autoGenStale = false;

            this.broadcastToAll({
              type: 'auto-generating',
              payload: { isGenerating: false, error: status.error },
            } as any);
          }
        } catch (pollError) {
          console.error('[Radio] Poll error:', pollError);
        }
      }, 3000); // Poll every 3 seconds

      // Timeout after 5 minutes
      setTimeout(() => {
        if (this.state.isAutoGenerating) {
          clearInterval(pollInterval);
          console.error('[Radio] Auto-generation timed out');
          this.state.isAutoGenerating = false;

          this.broadcastToAll({
            type: 'auto-generating',
            payload: { isGenerating: false, error: 'Timed out' },
          } as any);
        }
      }, 5 * 60 * 1000);

    } catch (error) {
      console.error('[Radio] Auto-generation error:', error);
      this.state.isAutoGenerating = false;

      this.broadcastToAll({
        type: 'auto-generating',
        payload: { isGenerating: false, error: (error as Error).message },
      } as any);
    }
  }

  /** Helper to apply cached LLM data fields via setter callbacks */
  private applyLLMData(
    llmData: LLMSongData,
    setters: {
      title: (v: string) => void;
      style: (v: string) => void;
      lyrics: (v: string) => void;
      duration: (v: number) => void;
      bpm: (v: number) => void;
      keyScale: (v: string) => void;
      timeSignature: (v: string) => void;
    },
  ): void {
    if (llmData.song_title) setters.title(llmData.song_title);
    if (llmData.prompt) setters.style(llmData.prompt);
    if (llmData.lyrics !== undefined) setters.lyrics(llmData.lyrics);
    if (llmData.audio_duration) setters.duration(llmData.audio_duration);
    if (llmData.bpm) setters.bpm(llmData.bpm);
    if (this.state.settings.autoDjKeyRandomize !== false) {
      setters.keyScale(KEY_SCALES[Math.floor(Math.random() * KEY_SCALES.length)]);
    } else if (llmData.key_scale) {
      setters.keyScale(llmData.key_scale);
    }
    if (llmData.time_signature) setters.timeSignature(llmData.time_signature);
  }

  voteDjStyle(listenerId: string, style: 'explore' | 'similar' | 'consistent'): boolean {
    if (this.state.settings.autoDjStyleLocked) return false;
    if (!this.state.listeners.has(listenerId)) return false;

    this.state.djStyleVotes.set(listenerId, style);
    this.broadcastDjStyleVotesUpdate();

    // Count votes per style
    const counts = this.getDjStyleVoteCounts();
    const required = this.getSkipRequired(); // Same threshold as skip voting

    // Check if any style reached the threshold
    for (const [s, count] of Object.entries(counts)) {
      if (count >= required && s !== this.state.settings.autoDjStyle) {
        console.log(`[Radio] DJ style vote threshold reached for "${s}" (${count}/${required})`);
        this.state.settings.autoDjStyle = s as 'explore' | 'similar' | 'consistent';
        this.saveSettingsToDb();
        this.broadcastSettingsUpdate();
        this.state.djStyleVotes.clear();
        this.broadcastDjStyleVotesUpdate();
        break;
      }
    }

    return true;
  }

  getDjStyleVoteCounts(): { explore: number; similar: number; consistent: number } {
    const counts = { explore: 0, similar: 0, consistent: 0 };
    this.state.djStyleVotes.forEach((style) => {
      counts[style]++;
    });
    return counts;
  }

  getPublicState(): {
    currentSong: RadioSong | null;
    playbackStartTime: number;
    queue: RadioSong[];
    history: RadioSong[];
    listeners: Array<{ id: string; name: string }>;
    listenerCount: number;
    skipVotes: number;
    skipRequired: number;
    djStyleVotes: { explore: number; similar: number; consistent: number };
    djStyleVoteRequired: number;
    ownerId: string | null;
    settings: RadioSettings;
  } {
    return {
      currentSong: this.state.currentSong,
      playbackStartTime: this.state.playbackStartTime,
      queue: this.state.queue,
      history: this.state.history,
      listeners: Array.from(this.state.listeners.values()).map(l => ({
        id: l.id,
        name: l.name,
      })),
      listenerCount: this.state.listeners.size,
      skipVotes: this.state.skipVotes.size,
      skipRequired: this.getSkipRequired(),
      djStyleVotes: this.getDjStyleVoteCounts(),
      djStyleVoteRequired: this.getSkipRequired(),
      ownerId: this.state.ownerId,
      settings: this.sanitizeSettings(this.state.settings),
    };
  }

  getSettings(): RadioSettings {
    return { ...this.state.settings };
  }

  getSanitizedSettings(): RadioSettings {
    return this.sanitizeSettings(this.state.settings);
  }

  /**
   * Update generation params immediately when a user request starts.
   * This ensures auto-DJ uses new params even if it kicks in before the song completes.
   */
  updateGenParams(genParams: Partial<AutoGenParams>): void {
    if (this.state.lastGenParams) {
      // Merge new params, preserving any fields not being updated
      this.state.lastGenParams = { ...this.state.lastGenParams, ...genParams };
      console.log('[Radio] Updated gen params immediately from user request');
    } else {
      // No previous params, create new
      this.state.lastGenParams = genParams as AutoGenParams;
      console.log('[Radio] Created new gen params from user request');
    }
  }

  /**
   * Cancel pre-generation timeout (called when user starts a new request)
   */
  cancelPreGeneration(): void {
    if (this.preGenerateTimeout) {
      clearTimeout(this.preGenerateTimeout);
      this.preGenerateTimeout = null;
      console.log('[Radio] Cancelled pre-generation (user request started)');
    }
  }

  /**
   * Cancel auto-generation: clears pre-gen timeout AND marks in-flight auto-gen as stale
   */
  cancelAutoGeneration(): void {
    this.cancelPreGeneration();
    if (this.state.isAutoGenerating) {
      this.state.autoGenStale = true;
      console.log('[Radio] Marked auto-generation as stale (user request started)');
    }
  }

  updateSettings(settings: Partial<RadioSettings>): void {
    this.state.settings = { ...this.state.settings, ...settings };

    // Auto-switch interaction mode when AI is disabled
    if ('useLLM' in settings && settings.useLLM === false && this.state.settings.interactionMode === 'vibe') {
      this.state.settings.interactionMode = 'create';
    }

    this.saveSettingsToDb();
    this.broadcastSettingsUpdate();

    // Re-init LLM provider if LLM settings changed
    if ('useLLM' in settings || 'llmProvider' in settings || 'llmClaudeSettings' in settings || 'llmVllmSettings' in settings) {
      this.initLLMFromSettings();
    }

    // Update music provider URL if changed
    if ('musicProviderUrl' in settings && settings.musicProviderUrl) {
      setMusicProviderUrl(settings.musicProviderUrl);
    }
  }

  requeueFromHistory(songId: string, listenerId: string): boolean {
    // Find the song in history
    const song = this.state.history.find(s => s.id === songId);
    if (!song) {
      console.log('[Radio] Song not found in history:', songId);
      return false;
    }

    // Get listener name for the requeued song
    const listener = this.state.listeners.get(listenerId);
    const requesterName = listener?.name || 'Someone';

    // Create a copy of the song with updated info
    const requeuedSong: RadioSong = {
      ...song,
      id: `${song.id}_requeue_${Date.now()}`, // New ID to avoid duplicates
      creator: `${song.creator || 'Unknown'} (requeued by ${requesterName})`,
      createdAt: new Date(),
      isAutoDJ: false, // User requested, so not Auto-DJ
    };

    console.log('[Radio] Requeuing song from history:', requeuedSong.title);

    // Add to queue as user-generated (will remove Auto-DJ songs)
    this.addToQueue(requeuedSong, song.genParams, true);

    return true;
  }

  broadcastChatMessage(senderId: string, message: string): void {
    const listener = this.state.listeners.get(senderId);
    if (!listener) return;

    const chatMessage: ChatMessage = {
      id: `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      senderId,
      senderName: listener.name,
      message,
      timestamp: Date.now(),
    };

    // Save to database
    this.saveChatMessage(chatMessage);

    // Keep in memory (limit to 100 messages)
    this.state.chatMessages.push(chatMessage);
    if (this.state.chatMessages.length > 100) {
      this.state.chatMessages = this.state.chatMessages.slice(-100);
    }

    // Broadcast to all listeners
    this.broadcastToAll({
      type: 'chat-message',
      payload: chatMessage,
    } as any);
  }

  private getSkipRequired(): number {
    const listenerCount = this.state.listeners.size;
    if (listenerCount === 0) return 1;
    return Math.max(1, Math.ceil(listenerCount * config.radio.skipVotePercent));
  }

  private sendTo(ws: WebSocket, event: RadioEvent): void {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(event));
    }
  }

  broadcastToAll(event: RadioEvent): void {
    const message = JSON.stringify(event);
    this.state.listeners.forEach(listener => {
      if (listener.ws.readyState === WebSocket.OPEN) {
        listener.ws.send(message);
      }
    });
  }

  private broadcastSongChange(): void {
    console.log('[Radio] Broadcasting song-change to', this.state.listeners.size, 'listeners');
    this.broadcastToAll({
      type: 'song-change',
      payload: {
        song: this.state.currentSong,
        startTime: this.state.playbackStartTime,
      },
    });
  }

  private broadcastQueueUpdate(): void {
    this.broadcastToAll({
      type: 'queue-update',
      payload: { queue: this.state.queue },
    });
  }

  private broadcastHistoryUpdate(): void {
    this.broadcastToAll({
      type: 'history-update',
      payload: { history: this.state.history },
    });
  }

  private broadcastListenersUpdate(): void {
    this.broadcastToAll({
      type: 'listeners-update',
      payload: {
        listeners: Array.from(this.state.listeners.values()).map(l => ({
          id: l.id,
          name: l.name,
        })),
        count: this.state.listeners.size,
      },
    });
  }

  private broadcastSkipVotesUpdate(): void {
    this.broadcastToAll({
      type: 'skip-votes-update',
      payload: {
        votes: this.state.skipVotes.size,
        required: this.getSkipRequired(),
      },
    });
  }

  private broadcastDjStyleVotesUpdate(): void {
    this.broadcastToAll({
      type: 'dj-style-votes-update',
      payload: {
        votes: this.getDjStyleVoteCounts(),
        current: this.state.settings.autoDjStyle || 'explore',
        required: this.getSkipRequired(),
        locked: this.state.settings.autoDjStyleLocked || false,
      },
    });
  }

  private broadcastOwnerChange(): void {
    this.broadcastToAll({
      type: 'owner-change',
      payload: { ownerId: this.state.ownerId },
    });
  }

  /** Strip secrets before sending settings to clients */
  private sanitizeSettings(settings: RadioSettings): RadioSettings {
    const sanitized = { ...settings };
    if (sanitized.llmClaudeSettings?.apiKey) {
      sanitized.llmClaudeSettings = { ...sanitized.llmClaudeSettings, apiKey: '••••••••' };
    }
    return sanitized;
  }

  private broadcastSettingsUpdate(): void {
    this.broadcastToAll({
      type: 'settings-update',
      payload: { settings: this.sanitizeSettings(this.state.settings) },
    });
  }
}

// Singleton instance
export const radioManager = new RadioManager();
